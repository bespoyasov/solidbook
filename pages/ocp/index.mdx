import {MainLayout} from '~/layouts/main'
import {Figure} from '~/components/Figure'
import {Quiz} from '~/components/Quiz'

export const meta = {
  title: 'OCP | Введение',
  description: 'Введение в принцип открытости-закрытости, его смысл, основные понятия'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Введение

Проектируя систему, мы занимаемся моделированием, а значит решаем инженерную задачу. Мы строим гипотезу о том, каковы отношения между сущностями в этой системе.

Однако бизнес-требования не вечны, они могут (и будут) меняться. Хорошо спроектированная система способна пережить эти изменения, отразить их в себе и продолжить функционировать.

Основная причина, по которой вносить изменения бывает трудно или дорого — когда небольшое изменение в одной части системы вызывает лавину изменений в других частях. Грубо и утрировано: если в программе для изменения цвета кнопки надо поправить 15 модулей, такая система спроектирована плохо.

## Принцип открытости-закрытости
[Принцип открытости-закрытости](https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости) (Open-Closed Principle, OCP) помогает исключить такую проблему. Согласно ему модули должны быть открыты для расширения, но закрыты для изменения.

Простыми словами — модули надо проектировать так, чтобы их нельзя было менять, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

Модули, которые удовлетворяют OCP:
- _открыты для расширения_ — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- _закрыты для изменения_ — расширение функциональности модуля не должно приводить к изменениям в модулях, которые его используют.

Конечно, всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля — никакая система не может быть закрыта на 100%. Поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть. Это решение следует принимать опираясь на опыт, а также знания предметной области и пользователей системы.

Нарушение принципа открытости-закрытости приводит к ситуациям, когда изменение в одном модуле вынуждает менять другие, связанные с ним. Это в свою очередь [нарушает принцип единой ответственности, SRP](/srp), потому что весь код, который меняется по какой-то одной причине, должен быть собран в одном модуле. (Разные модули — разные причины для изменения.)

## На примере
На схеме ниже объект `Client` непосредственно связан с объектом `Server`. Если нам вдруг понадобится, чтобы `Client` мог работать с разными объектами `Server`, нам придётся поменять его код.
<Figure>
  <img src="/ocp-violation.svg" />
  <figcaption>Структура, нарушающая OCP</figcaption>
</Figure>

Чтобы решить эту проблему, необходимо связывать объекты не напрямую, а через абстракции. Если все объекты `Server` реализуют интерфейс `Abstract Server`, то нам уже не придётся менять код объекта `Client` для замены одного объекта `Server` на другой.
<Figure>
  <img src="/ocp-resolve.svg" />
  <figcaption>Абстракция помогает развязать модули</figcaption>
</Figure>

### В коде

Если попробовать выразить этот принцип в коде, то самым простым примером будет замена множественных проверок на принадлежность к типу на абстракцию.

Например, мы пишем сервис рассылки сообщений. Он принимает текст, который надо выслать, и сервис стороннего API для отправки СМС, пушей или электронных писем. Плохо спроектированный сервис мог бы выглядеть так:

```ts
class SmsSender {
  sendSms(message: MessageText) { /* ... */ }
}

class PushSender {
  sendPush(message: MessageText) { /* ... */ }
}

class EmailSender {
  sendEmail(message: MessageText) { /* ... */ }
}

class Notifier {
  constructor(private api: SmsSender | PushSender | EmailSender) {}

  notify(): void {
    const message = 'Some user notification';

    if (this.api instanceof SmsSender) {
      this.api.sendSms(message)
    } else if (this.api instanceof PushSender) {
      this.api.sendPush(message)
    } else if (this.api instanceof EmailSender) {
      this.api.sendEmail(message)
    }
  }
}
```

Проблема этого кода в том, что при _добавлении_ нового типа стороннего API — голубиной почты — нам придётся _менять_ уже существующий код.

```ts
// ...Предыдущие классы.

// Добавили новый тип стороннего API:
class DoveSender {
  sendDove(message: MessageText) { /* ... */ }
}

class Notifier {
  constructor(private api: SmsSender | PushSender | EmailSender | DoveSender) {}

  notify(): void {
    const message = 'Some user notification';

    if (this.api instanceof SmsSender) {
      this.api.sendSms(message)
    } else if (this.api instanceof PushSender) {
      this.api.sendPush(message)
    } else if (this.api instanceof EmailSender) {
      this.api.sendEmail(message)
    } else if (this.api instanceof DoveSender) { // Последние 3 строчки —
      this.api.sendDove(message)                 // ...это новый код,
    }                                            // ...который пришлось добавить.
  }
}
```

### Вместо этого

OCP же предлагает не проверять конкретные типы, а использовать абстракцию, которая позволит не менять код класса `Notifier`. Для этого мы создадим интерфейс `Sender`, который будут реализовывать классы `SmsSender`, `PushSender` и `EmailSender`:

```ts
// Интерфейс будет абстракцией, которая описывает контракт,
// по которому должны работать классы, реализующий этот интерфейс.
interface Sender {
  sendMessage(message: MessageText): void
}

class SmsSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода sendSms. */
  }
}

class PushSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода sendPush. */
  }
}

class EmailSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода sendEmail. */
  }
}
```

Тогда классу `Notifier` перестанет быть нужно проверять конкретный тип, и он сможет положиться на контракт, описанный в интерфейсе:

```ts
class Notifier {
  constructor(private api: Sender) {}

  notify(): void {
    const message = 'Some user notification';
    this.api.sendMessage(message);
  }
}
```

### В результате

Теперь при _добавлении_ голубиной почты, нам уже не потребуется _менять_ код класса `Notifier`, зависящего от интерфейса `Sender`:

```ts
class DoveSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода sendDove. */
  }
}

// Код класса Notifier останется тем же.
```

Таким образом, вводя адекватную абстракцию мы «расцепляем» модули. Мы делим зоны ответственности между разными частями приложения и уменьшаем количество кода, который нужно изменять при добавлении новой функциональности.

## Коротко
Принцип открытости-закрытости:
- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

## Материалы к разделу
- [Принцип открытости-закрытости](https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости)
- [Open-closed principle, Duke computer science](https://www2.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf)
- [Clarifying my use of the open/closed principle, Eric Elliott](https://medium.com/@_ericelliott/clarifying-my-use-of-the-open-closed-principle-de54f77342c3)
- [Научный метод](https://ru.wikipedia.org/wiki/Научный_метод)
- [Основы теории решения изобретательских задач](https://ru.wikibooks.org/wiki/Основы_ТРИЗ)

## Вопросы
<Quiz name='ocp-intro-1' />
<Quiz name='ocp-intro-2' />
