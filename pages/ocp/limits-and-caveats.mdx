import {MainLayout} from '~/layouts/main'

export const meta = {
  title: 'OCP | Ограничения и подводные камни',
  description: 'Ограничения принципа открытости-закрытости, с которыми разработчики сталкиваются чаще всего'
}

export default ({ children }) => <MainLayout meta={meta}>{children}</MainLayout>

# Ограничения и подводные камни

У каждого принципа есть ограничения и область применения. Для OCP характерны следующие ограничения и подводные камни.

## Система не может быть закрыта на 100%

Всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля, поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть.

Следует учитывать, что люди очень плохо умеют прогнозировать изменения. Даже имея достаточно знаний о системе и опыта, проектировщики не могут быть уверены, что предусмотрели все возможные варианты развития системы.

OCP предлагает подход [Just-in-time design](https://agiledesign.org/2015/01/18/jit-just-in-time-and-software-development/), при котором новые сущности добавляются в систему по мере необходимости, но не раньше. Это чем-то похоже на отказ от ранней оптимизации и [раннего добавления абстракций](http://tonsky.me/blog/concrete-vs-abstract/).

Цель подхода в том, чтобы не создавать абстракции на пустом месте. Один из критериев хорошего дизайна — простота, поэтому использовать OCP следует всегда с оглядкой на то, насколько система получится простой в итоге.

## Большое количество сущностей

Добавление функциональности менее рискованно, чем изменение существующей, но взамен мы рискуем [увеличить количество сущностей](https://softwareengineering.stackexchange.com/questions/170547/refactoring-and-open-closed-principle). Бесконтрольное и бездумное следование OCP может приводить к ситуациям, когда интерфейсов станет слишком много, а функциональность — станет раздробленной.

Хороший дизайн системы — это в первую очередь простой дизайн. Чем меньше сущностей мы создаём для решения проблемы, тем [выше вероятность, что дизайн хороший](https://ru.wikipedia.org/wiki/Дзен_Питона), поэтому следовать OCP необходимо с осторожностью.

## Может быть не нужен для маленьких приложений

OCP нацелен на быстрое и дешёвое добавление функциональности и масштабирование системы. Он окупается, если система действительно большая, и проверять, как повлияло изменение кода, очень дорого или долго (или невозможно).

Если же приложение маленькое, то OCP может [превратиться в принцип ради принципа](https://www.tonymarston.net/php-mysql/not-so-solid-oo-principles.html) — когда разработчики будут писать бойлерплейт-код для создания новых сущностей без видимой и ощутимой пользы.

OCP следует применять, если польза от него значительно выше, чем затраты от следования ему.

## Материалы к разделу

- [Just-in-time design](https://agiledesign.org/2015/01/18/jit-just-in-time-and-software-development/)
- [Solve problem at hand](http://tonsky.me/blog/concrete-vs-abstract/)
- [Refactoring and OCP](https://softwareengineering.stackexchange.com/questions/170547/refactoring-and-open-closed-principle)
- [Дзен питона](https://ru.wikipedia.org/wiki/Дзен_Питона)
- [Бритва Оккама](https://ru.wikipedia.org/wiki/Бритва_Оккама)
- [Not so SOLID principles](https://www.tonymarston.net/php-mysql/not-so-solid-oo-principles.html)
